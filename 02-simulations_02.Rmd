
# Evolutionary Simulations

```{r, include = FALSE}
ottrpal::set_knitr_image_path()
```

## Setup

Load the `tidyverse` library (which includes `ggplot2`) to use for the rest of the module:

```{r, results = FALSE, message = FALSE, warning = FALSE}
library(tidyverse)
```


## Building a Wright-Fisher simulation

### Drawing one generation from a binomial distribution

The basis of our simulation is R's `rbinom` function, which allows us to sample from a binomial distribution. `rbinom` takes three arguments:

* `n`: how many times we're drawing from the distribution
* `size`: the size of the population we're sampling from (i.e. `N`)
* `p`: the success probability (i.e. allele frequency)

Every generation, we will draw **once** to produce the number of individuals carrying the `A` allele in the next generation.

Let's once again look at a population of size 100, and an `A` allele currently at `AF = 0.5`. We use `rbinom` to get the number of individuals in the next generation who will have the `A` allele:

```{r}
rbinom(n = 1, size = 100, prob = 0.5)
```

**Coding exercise**: Change the code above so that it returns the allele frequency rather than the number of individuals.

***
<details> <summary> Solution </summary>
```{r}
# divide by the population size to get AF
rbinom(n = 1, size = 100, prob = 0.5) / 100
```
</details>
***

**Question**: You'll notice that every time we run the `rbinom` line, the number we get is different. Why is that?

***
<details> <summary> Solution </summary>
`rbinom` generates a random number between 1 and 100. Because it's random, the number it draws will be different every time we run it.
</details>
***

Currently, we're drawing from a population of 100 individuals. Now let's see what happens when we increase the population size. (Feel free to run this code block multiple times!)

```{r}
rbinom(n = 1, size = 10000, prob = 0.5) / 10000
```

If you run the code block above multiple times, you'll observe that the AF is much closer to 0.5 than it was with a population of size 100. This lends to our intuition that an allele's frequency fluctuates much more when a population is small, and is more stable when the population size is large.

**Question**: As you increase population size, how does that affect an allele's time to fixation?

***
<details> <summary> Answer </summary>
As population size gets larger, the allele will take longer to fix.
</details>
***

### Simulating multiple generations with a for loop

We can now draw _once_ from a binomial distribution to get the number of individuals in one generation who carry the `A` allele. How do we adapt this to simulate multiple generations?

**Question**: Can we increase `n` (for example, with `rbinom(n = 10, size = 100, prob = 0.5)`) to draw multiple times?

***
<details> <summary> Solution </summary>
No. Increasing `n` only gives you multiple replicate draws from the same distribution. It won't update the AF between generations based on the new number of `A` alleles, because it uses `prob = 0.5` every time.
</details>
***

Instead of drawing multiple times from the same distribution, we write a **for loop** to repeatedly generate and update the number of individuals with the `A` allele.

A **for loop** allows you to run some code X number of times. For example:

```{r}
for (i in 1:3) {
  print(i)
}
```

This for loop goes through all the values between 1 and 3, and prints each of them out.

We can write a similar for loop that includes `rbinom`:

```{r}
for (i in 1:3) {
  print(rbinom(n = 1, size = 100, prob = 0.5) / 100)
}
```

This is very close to what we want. However, we're still running `rbinom` with the same AF in every iteration.

How do we change this to update the AF each generation? We can add a `freq` variable that keeps track of the current allele frequency:

```{r}
# start an initial AF of 0.5
freq <- 0.5

for (i in 1:3) {
  # run rbinom to generate the AF for the next generation
  new_freq <- rbinom(n = 1, size = 100, prob = freq) / 100
  # print so that we can see what `freq` is each time
  print(new_freq)
  # update `freq` in each iteration of the loop
  freq <- new_freq
}
```

Now the for loop is updating the allele's frequency every generation and running `rbinom` with that new frequency.

One more modification: Providing the variable `freq` as an input to `rbinom` allows us to update `freq` with each for loop iteration. But it also allows us to pass `rbinom` a variable, rather than hard-coding in a population size.

**Coding exercise**: Add to the code above so that we also provide `Ne` (effective population size) as a variable (_without_ updating it in the for loop).

***
<details> <summary> Solution </summary>
```{r}
# set effective population size outside of for loop
Ne <- 100
# start an initial AF of 0.5
freq <- 0.5

for (i in 1:3) {
  # run rbinom to generate the AF for the next generation
  new_freq <- rbinom(n = 1, size = Ne, prob = freq) / Ne
  # print so that we can see what `freq` is each time
  print(new_freq)
  # update `freq` in each iteration of the loop
  freq <- new_freq
}
```
</details>
***

## Plotting & creating a simulation function

### Visualizing changes in AF over generations

Try increasing the number of generations we run the simulation for. What patterns of change do you observe in the allele frequencies?

```{r}
Ne <- 100
freq <- 0.5

for (i in 1:20) {
  new_freq <- rbinom(n = 1, size = Ne, prob = freq) / Ne
  print(new_freq)
  freq <- new_freq
}
```

It would be useful to plot how the AF changes over time, so that we can look at it visually. We can do this by storing the AF at each generation in a **vector**, which you can think of as R's version of a list.

Vectors are formed with the `c()` function, which stands for "combine":

```{r}
my_vec <- c(0.5, 0.6)
my_vec
```

You can append elements to a vector called `my_vec` by running: `my_vec <- c(my_vec, new_element)`.

**Coding exercise**: Modify the code block with our for loop to create a vector for storing allele frequencies, and then append the updated AF to it every generation.

***
<details> <summary> Hint </summary>
Create the vector **before** the for loop. Then append to the vector **within** the for loop.
</details>
***

***
<details> <summary> Solution </summary>
```{r}
Ne <- 100
freq <- 0.5
# create vector to store AFs in
freq_vector <- freq

for (i in 1:20) {
  new_freq <- rbinom(n = 1, size = Ne, prob = freq) / Ne
  # add new freq to the AF vector
  freq_vector <- c(freq_vector, new_freq)
  freq <- new_freq
}

freq_vector
```
</details>
***

We can plot this allele frequency vector with `ggplot`. First, because `ggplot` requires its input data to be formatted as a table, we have to convert the vector into some form of table. (We chose `tibble` form here because it's easy to convert to.)

```{r}
sim_results <- tibble(af = freq_vector)
sim_results
```

This table contains the information that we want on the plot's y axis. We can now add in a column containing the plot's x axis data. This should be the **generation** that each AF value corresponds to.

```{r}
sim_results <- tibble(af = freq_vector,
                      gen = 1:21)
sim_results
```

***
<details> <summary> Why does the `gens` column go from 1 to 21 (instead of 20)? </summary>
We add our starting allele frequency to `freq_vector`, and then simulate 20 generations of drift. This means that we end up with 21 AFs in our vector.
</details>
***

Now we can finally plot the trajectory of AFs over time with `ggplot`.

```{r}
ggplot(data = sim_results,
       aes(x = gen, y = af)) +
  geom_line()
```

### Simulating with different parameters by using a function

It would be nice to be able to run the Wright-Fisher simulation with different parameters -- like different starting allele frequencies, population sizes, etc. -- without having to modify the for loop code every time. We can use a **function** to generalize the code above so we can easily re-run it.

Whenever you have a bunch of lines at the beginning of your code where you set variables, you should always be thinking that you can make it into a function.

***
<details> <summary> The structure of an R function </summary>

You've already encountered many functions in R, even if you didn't realize it at the time - `rbinom`, `ggplot`, and `print` are all examples of functions. An R function has [four parts](https://www.tutorialspoint.com/r/r_functions.htm):

```
<Name> <- function(<Argument(s)>) {
  <Body>
  <return()>
}
```

* **Name** − The function is stored in your R environment as an object with this name, and you use the name to call it
* **Argument(s)** − Optional; input values that the function performs operations on
* **Body** − The code that describes what the function does
* **Return** − Optional; a `return` statement allows the function to return a value to the user. Without a return statement, you won't be able to access the function's output

Here's an example function that takes in three parameters for running `rbinom`, and returns the output of `rbinom`.
```
binom_sim <- function(myN, mySize, myProb) {
  output <- rbinom(n = myN, size = mySize, prob = myProb)
  return(output)
}
```
</details>
***

We want our function to take in parameters for the starting allele frequency, population size, and number of generations to simulate. It should return the `sim_results` dataframe so that we can plot the allele frequency trajectory.

To write a function, we can place the code that we just wrote into the function body:

```{r}
run_sim <- function(Ne, freq, generations) {
  
  # note how we don't define our initial parameters for Ne, freq, etc.
  # because we're passing in those parameters as arguments
  
  freq_vector <- freq
  for (i in 1:generations) {
    new_freq <- rbinom(n = 1, size = Ne, prob = freq) / Ne
    freq_vector <- c(freq_vector, new_freq)
    freq <- new_freq
  }
  
  # convert vector of AFs into a tibble for plotting
  sim_results <- tibble(afs = freq_vector,
                        gen = 1:(generations+1))
  
  # return the tibble of AFs, so that we can access the results
  return(sim_results)
}
```

Now we can run the function with parameters of our choosing and plot the output:

```{r}
# run function
results <- run_sim(Ne = 1000, freq = 0.5, generations = 10000)

# plot output
ggplot(data = results,
       aes(x = gen, y = afs)) +
  geom_line()
```

**Exercise**: Run your `run_sum` function a few times with different input population sizes and allele frequencies. How does changing thesse inputs affect the allele frequency trajectories that you see?

***
<details> <summary> How do I know when to use a function? </summary>
Functions are useful whenever you have code that you want to run multiple times with slightly different parameters. If you find yourself copying over code several times and changing just a few things, you should consider writing a function instead.
</details>
***

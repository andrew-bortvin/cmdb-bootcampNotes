```{r, include = FALSE}
ottrpal::set_knitr_image_path()
```

# Python 

## Data Types, Variables, Math

### Types of Data

**Integers** Integers are whole numbers, without a decimal point. For example:

* 2
* -3 
* 0

**Floats** Floats are numbers with a decimal point. For example: 

* 1.2
* -3.0
* 26/3 (This one doesn't actually have a decimal point written in by me, but is a float because the expression evaluates to 8.666)

**Strings** Strings are character data enclosed by single ' or double " quotation marks. Any text enclosed by quotes will be treated as a string.

* "My Grandpa's deck has no pathetic cards"
* '85.3'

Note the second example – `85.3` is a float; `"85.3"` is a string.

**Booleans** A Boolean has two possible values: `True` and `False`. These can be expressed interchangeably as `1` or `0`, respectively.  

### Variables

A variable is assigned using the equals sign, with this general syntax:

`variable_name = value`. 

For example:

* `composer = "buxtehude"` 
* `year = 1637` 

The data name can be almost anything. Here are the rules to consider when naming a variable:

* A variable name must start with a letter or underscore
* A variable name can only consist of letters, numbers, or underscores
* Variables are case sensitive (i.e. Python would interpret my_number, MY_NUMBER, and My_Number as different variables)
* Python has a set of "reserved words" that cannot be used as variable names. These are words that already have a set meaning in Python, such as 'True', 'False', 'for', and 'if'. A full list can be found here: https://www.programiz.com/python-programming/keywords-identifier

### Mathematical Operations 

A lot of mathematical operations in Python are straightforward. Here are some of the basic operations we can perform

* `+` and `-` – addition and subtraction
* `*` and `/` – multiplication and division
* `**` – Exponentials

We can perform mathematical operations on values directly:

```{r, engine="python"}
print(2 + 3)
```

or we can operate on variables: 

```{r, engine="python"}
myValue = 4 
print(myValue**2)
```

Mathematical conversions will automatically convert integers to floats when appropriate: 

```{r, engine="python"}
print(3 + 2.2)
```

We can save the output of an expression as a variable:

```{r, engine="python"}
my_product = 2 * 10
print(my_product)
```

And likewise we can perform mathematical operations on variables, provided these variables store numeric data: 

```{r, engine="python"}
number1 = 7
print(number1 / 2)
```

### Order of operations

Python follows the usual mathematical order of operations. And like usual in math, we can use parenthesis () to enforce a specific order.

```{r, engine="python"}
print(6 - 7 * 2 + (8-4) * 4)
```

### Comparisons 

In Python, comparisons will always return a Boolean, i.e. either True or False. We can use the following syntax to compare values:

* `<` and `>` to compare greater than/less than
* `<=` and `>=` for greater than or equal to/less than or equal to

For example: 

```{r, engine="python"}
print(5.3 < 17)
print(4. >= (8/2))
```

* `==` checks if two values are equal. `!=` checks that two values are different.

```{r, engine="python"}
print((2**3) != (17 - 9))
```

Note that a single equals sign = is used to assign values. So `var1 = 3` is setting `var1` equal to `3`. However, a double equals sign `==` is used to compare values. `var1 == 3` is checking if the value of `var1` is `3`.

## Built-In Functions and Methods 

### Functions

A **function** is a block of code that performs a task. Python comes with a substantial set of pre-written functions. 

***Text on how a function is formulated - name, parentheses, optionally arguments*** 

***Is it worth talking about named arguments or positional arguments. Be introspective about this***

For example, the `print()` function displays ***FINISH ME***

***OTHER Built-In FUNCTIONS***'

### Methods

Every data type that we use in Python (that is, strings, integers, etc.) is associated with a set of functions unique to the data type. These functions are called **methods**. The syntax for using a method is as follows: `<objectName>.<methodName>()`. For example, the method `.upper()` belongs to strings and is used to convert a string into capital letters. We can use it with any string either directly on the string itself: 

```{r, engine="python"}
"Quod est superius est sicut quod inferius".upper()
```

or by operating on a variable: 

```{r, engine="python"}
pig = "peppa"
pig.upper()
```

Using a method may or not modify the underlying object. For example, the `.upper()` method shows you the uppercase version of a string but does *not* modify the actual variable that you are operating on. Observe the following code block:

```{r, engine="python", eval = FALSE}
pig = "peppa"
pig.upper()
```

We've returned the uppercase version of the `pig` variable, but has this value been saved? No: 

```{r, engine="python"}
print(pig)
```

To actually save the result of this method, we have to use variable assignment, for example like so: 

```{r, engine="python"}
pig = "peppa"
pig = pig.upper()
print(pig)
```

Some methods *do* in fact modify underlying variables. For example, the list `.append()` method which we will learn about later *does* change the list if operates on, so in the following code block: 

```{r, engine="python"}
myList = []
myList.append('apple')
```

`myList` is changed by `myList.append('apple')`. There's no need to type something like `myList = myList.append('apple')` - this would in fact be an error. Which methods modify the objects they operate on is something you'll have to keep track of on a case-by-case basis as you learn new methods. 

## Type Conversion


## String Methods

### .upper() and .lower()

The `.upper()` and `.lower()` methods take a string and convert it to uppercase and lowercase, respectively. 

```{r, engine='python'}
print("out on the wily, windy moors".upper())
```

```{r, engine='python'}
aria = "Piangerò La Sorte Mia"
print(aria.lower())
```

### .split()

The `.split()` method takes a string and splits it into a list, dividing the list on by a regular delimiter. The delimiter is provided as an argument:

```{r, engine='python'}
print("Eye of newt, toe of frog, wool of bat".split(','))
```

If no argument is provided, then the string is split on whitespace (that is, it is split whenever a space or tab is encountered). 

```{r, engine='python'}
print("they sowed their isn’t       they reaped their same".split())
```

### .join()

The `.join()` method is the inverse of `.split()` - takes a list and converts it into a string, with list elements separated by a delimiter. The general syntax is: `"<delimiter>".join(<list to join>)`

```{r, engine='python'}
'.'.join(["39","3299","-76","620277"])
```

We can provide a space as a delimiter:

```{r, engine='python'}
"".join(["I", "found", "a", "fox", "caught", "by", "dogs"])
```

If we do not provide a delimiter, then the strings are directly concatenated: 

```{r, engine='python'}
"".join(["here", "in", "after"])
```

### .strip()

***ADD***

## Lists 

Each variable has stored a single piece of information, e.g. a single integer or a discrete string. Lists allow us to store multiple items together?

A list is a sequential group of variables, denoted in Python by square brackets [], with individual entries separated by commas. A few of the neat properties of lists are:

* Lists have a preserved order. The list `[1, 5, 3, 7]` will always store those numbers in the same order.
* Lists can mix data types. `["mercury", 13, 5.3, False]` is a valid list which contains every data type we've seen so far.
* Lists can also contain other lists: `["sulfur", 12, [3, 2], 18]`
* Lists can have identical values repeatedly. This is valid list design: ["tomato", "tomato", "tomato", 3, "tomato"]

### Indexing

What if we want to extract a specific value from a list? We can use indexing. To index in Python, we use the following syntax: `variable_name[index],` with `index` being an integer referring to the position we wish to extract.

```{r, engine="python"}
alchemists = ["Zosimos", "Oresme", "Flamel", "pseudo-Aristotle"]
print(alchemists[1])
```

Notice that when we printed the item at position 1, we printed out the second entry in my_list. This is because in Python, **indexes start at 0**. So to print out the first entry, we would use `alchemists[0]`.

A couple interesting things we can do with indexing:

* To print multiple consecutive number, we can provie two numbers separated by a colon `:`. Note that the first number is inclusive and the second number is exclusive. For example, in the sample below, we provide the index 1:3. This prints out the item at position 1 ('Oresme'), the item at position 2 ('Flamel') and not the item at position 3 ('pseudo-Aristotle').

```{r, engine="python"}
print(alchemists[1:3])
```

* We can index in reverse. To index from the end of the list, we use negative numbers.

```{r, engine="python", eval=FALSE}
print(alchemists[-1])
print(alchemists[-2])
print(alchemists[-3])
```

```{r, engine="python", echo=FALSE}
print(alchemists[-1])
print(alchemists[-2])
print(alchemists[-3])
```

What if we have a list within a list? Consider the following list:

```{r, engine="python"}
my_list = [1, 2, [3, 4], 5]
```

How would we point to the number `3` in this list?

First, we can point to the interior list. The interior list is the third item in the list, so it is at position 2 (remember, indexing in Python starts at 0). So we can access the interior list with `my_list[2]`.

Within the interior list, 3 is the first item, so it is at position 0. It can be accessed with the syntax `my_list[2][0]`

```{r, engine="python", eval=FALSE}
my_list = [1, 2, [3, 4], 5]
print(my_list[2])
print(my_list[2][0])
```

```{r, engine="python", echo=FALSE}
my_list = [1, 2, [3, 4], 5]
print(my_list[2])
print(my_list[2][0])
```

#### Indexing Strings

We can also apply indexing to extract substrings from within a string. This is done identically to how we index a list:

```{r, engine='python'}
creature = 'stingray'
print(creature[0:5])
```

### Adding to lists - Append

One last interesting thing we can do with lists is we can add entries to the end of a list. We do this using the `append()` method, which is used with the following syntax:

`list_name.append(item)`

For an example:

```{r, engine="python"}
florilegium = ['marigold', 'thistle', 'wormwood']
florilegium.append('tansy')
print(florilegium)
```

## For Loops 

In Python, we will often want to perform an action more than once. For example, if we have a list, we might want to operate on every item within the list one by one. 

One way to do this is to make use of a for loop, which is structured like this:

```{r, engine='python', eval=FALSE}
for <temporary_variable> in <thing to loop through>:
    {do something}
```

For example:

```{r, engine='python'}
stations = ["Three Note Oddity", "Radio Londres", "Cherry Ripe", "Swedish Rhapsody"]

for i in stations:
  print(i)
```

Here is how the loop works:

In the line for `i in stations`: we are defining the temporary variable i (the name of this variable is arbitrary). We are also saying that we are looping through `stations`. So in this first iteration of the for loop, i takes on the value of the first item in `stations`, that is "Three Note Oddity". Now we perform all of the indented code, which here is just a single print() statement.

Now we go back and set the value of i to that of the second entry in `stations`, or "Radio Londres". We execute all of the indented code, printing out "Radio Londres".

Now we go back and set the value of i to that of the third value in `stations`, or "Cherry Ripe". And we keep on doing this until there is nothing left in my_list.

In the above example, there was a single indented line in the bodyo of the loop, but the for loop can be arbitrarily long. Here is an example of a for loop structured in the same way, but with more going on in the body of the loop:

```{r, engine='python'}
my_list = [1, 4, 6, 9, 10, 2]

for i in my_list:
  i = i + 3
  i = i ** 2
  print(i)
```

We can also use a for loop to perform an action a set number of times, even when we don’t have a list to loop through. To do so, we can use the range() function. We'll use this function a ton throughout the course. When we run the range() function with a single integer inside the paranthesis, it generates a sequence of numbers from 0 up to and not including the number provided. So to run a function 3 times, we would provide the for loop with range(3) (i.e. [0, 1, 2]).

```{r, engine='python'}
for i in range(3):
  print(i)
```

So far, the body of our for loops has always referenced the temporary variable `i`. We can also use a for loop to run a block of code repeatedly without actually manipulating the temporary variable within that block:

```{r, engine='python'}
for i in range(6):
  print("All work and no play")
```

## Reading in Data and Text Parsing




***FILL***



## Modules 

Often, we need to make use of functions beyond those that are packaged with Python. To do this, we can import a **module**, or a collection of pre-written functions. A module is imported with the following syntax: `import <module name>`. For example, to import the popular plotting module Matplotlib, we write:

```{r, engine='python', eval=FALSE}
import matplotlib.pyplot
```

To use a function from this module, we need to reference both the package name and the function name, with the general syntax: `moduleName.functionName()`. To user Matplotlib's `show()` function, we would write:

```{r, engine='python', eval=FALSE}
matplotlib.pyplot.show()
```

What if you don't want to write out `matplotlib.pyplot` in full each time that you run a Matplotlib function? To simplify this, we can give our modules a shorthand name. For example: 

```{r, engine='python', eval=FALSE}
import matplotlib.pyplot as plt
```

Now, instead of writing out `matplotlib.pyplot`, we can just write `plt`. The previous `matplotlib.pyplot.show()` command is shortened to:

```{r, engine='python', eval=FALSE}
plt.show()
```

## Plotting 

In this course, we will use the library Matplotlib for plotting. For concision, we will import the `matplotlib.pyplot` module with the name `plt`, as such:

```{r, engine='python', eval=FALSE}
import matplotlib.pyplot as plt
```










































































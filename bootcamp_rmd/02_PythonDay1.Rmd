```{r, include = FALSE}
ottrpal::set_knitr_image_path()
```

# Python 

## Data Types

**Integers** are whole numbers. For example:

* `2`
* `-3`
* `0`

**Floats** are numbers with a decimal point. For example: 

* `1.2`
* `-3.0`
* `26/3` (evaluates to `8.666`)

**Strings** are characters enclosed by single `'` or double `"` quotation marks. Any text enclosed by quotes will be treated as a string.

* `"My Grandpa's deck has no pathetic cards"`
* `'85.3'`

Note the second example – `85.3` is a float; `'85.3'` is a string.

**Booleans** have two possible values: `True` and `False`. These can also be expressed as `1` (true) or `0` (false).

## Variables

Variables are assigned using the `=` sign:

```
variable_name = value
```

For example:

* `composer = "buxtehude"`
* `year = 1637`

The variable name can be almost anything. Here are some general rules to consider when naming a variable:

* The name must start with a letter or underscore
* The name can only consist of letters, numbers, or underscores
* Variables are case sensitive (i.e. Python interprets `my_number`, `MY_NUMBER`, and `My_Number` as different variables)
* Python has a set of "reserved words" that cannot be used as variable names. These are words that already have a set meaning in Python, such as `True`, `False`, `for`, and `if`. A full list can be found [**here**](https://www.programiz.com/python-programming/keywords-identifier).

## Math

### Mathematical operations 

A lot of mathematical operations in Python are straightforward. Here are some of the basic operations we can perform:

* `+` and `-`: addition and subtraction
* `*` and `/`: multiplication and division
* `**`: exponentials

We can perform mathematical operations on values directly:

```{r, engine="python"}
print(2 + 3)
```

Or we can operate on variables: 

```{r, engine="python"}
myValue = 4 
print(myValue**2)
```

Python will automatically convert integers to floats when appropriate: 

```{r, engine="python"}
print(3 + 2.2)
```

We can save the output of an expression as a variable:

```{r, engine="python"}
my_product = 2 * 10
print(my_product)
```

And likewise we can perform mathematical operations on variables, if these variables store numeric data:

```{r, engine="python"}
number1 = 7
print(number1 / 2)
```

### Order of operations

Python follows the usual mathematical order of operations. And like in math, we can use parentheses `()` to enforce a specific order.

```{r, engine="python"}
print(2 * (2 + 2))
```

### Comparisons 

In Python, comparisons will always return a Boolean, i.e. either `True` or `False.` We can use the following syntax to compare values:

* `<` and `>`: greater than, less than
* `<=` and `>=`: greater than or equal to, less than or equal to

For example:

```{r, engine="python"}
print(5.3 < 17)
print(4. >= (8/2))
```

* `==` checks if two values are equal. `!=` checks if two values are different.

```{r, engine="python"}
print(2 == (10 - 8))
```

Note that a single equals sign `=` is used to assign values. However, a double equals sign `==` is used to compare values.

* `var1 = 3` sets the variable `var1` to `3`
* `var1 == 3` checks whether the value of `var1` is `3`

## Built-In Functions and Methods 

### Functions

A **function** is a block of code that performs a task. Python comes with a substantial set of pre-written functions. 

***Text on how a function is formulated - name, parentheses, optionally arguments*** 

***Is it worth talking about named arguments or positional arguments. Be introspective about this***

For example, the `print()` function displays ***FINISH ME***

***OTHER Built-In FUNCTIONS***'

### Methods

Every data type that we use in Python (strings, integers, etc.) is associated with a set of functions unique to the data type. These functions are called **methods**.

The syntax for using a method is:

```
<objectName>.<methodName>()
```

#### Example

The string method `.upper()` is used to convert a string into uppercase letters. We can use it either directly on the string itself:

```{r, engine="python"}
"peppa".upper()
```

or by operating on a variable:

```{r, engine="python"}
pig = "peppa"
pig.upper()
```

#### Modifying objects

Using a method may or not modify the object you run it on. For example, the `.upper()` method shows you the uppercase version of a string but **does not** modify the actual object that you are operating on. Observe the following code block:

```{r, engine="python", eval = FALSE}
pig = "peppa"
pig.upper()
print(pig)
```

```
## peppa
```

`pig` has not been updated. To actually save the result of `.upper()`, we have to assign it to a variable: 

```{r, engine="python"}
pig_caps = pig.upper()
print(pig_caps)
```

Some methods **do** modify underlying variables. For example, the list `.append()` method (which we will learn about later) *does* change the list if operates on: 

```{r, engine="python"}
myList = []
print(myList)
myList.append('apple')
print(myList)
```

`myList` is altered by `myList.append('apple')`. There's no need to type something like `myList = myList.append('apple')` - this would in fact be an error. Whether methods modify the objects they operate on is something you'll have to keep track of on a case-by-case basis as you learn new methods. 

## Type Conversion


## String Methods

### .upper() and .lower()

The `.upper()` and `.lower()` methods take a string and convert it to uppercase and lowercase, respectively.

```{r, engine='python'}
print("out on the wily, windy moors".upper())
```

```{r, engine='python'}
aria = "Piangerò La Sorte Mia"
print(aria.lower())
```

### .split()

The `.split()` method takes a string and splits it into a list, dividing the list on a **delimiter** (i.e., separator). The delimiter is provided as an argument:

```{r, engine='python'}
print("Newt eye, frog toe".split(','))
```

If no argument is provided, then the string is split on whitespace (that is, it is split whenever a space or tab is encountered).

```{r, engine='python'}
print("Eye of newt    and toe of frog".split())
```

### .join()

The `.join()` method is the inverse of `.split()`: converts a list into a string, with list elements separated by a delimiter. The general syntax is:

```
"<delimiter>".join(<list>)
```

For example:

```{r, engine='python'}
" ".join(["I", "found", "a", "fox", "caught", "by", "dogs"])
```

If we do not provide a delimiter, then the strings are directly concatenated: 

```{r, engine='python'}
"".join(["I", "found", "a", "fox", "caught", "by", "dogs"])
```

### .rstrip(), .lstrip(), .strip()

These three methods remove unwanted characters on the right, left, or both sides of a string. You can provide the characters you want to remove as an argument:

```{r, engine='python'}
"ricercar........,,,,,,".rstrip(",.")
```

Without an argument, the methods remove spaces: 

```{r, engine='python'}
"          ricercar ".lstrip()
```

Note that in the above example we strip the spaces to the left of the main text, but we **do not** remove the spaces from the middle or right end of the text.

## Lists 

Lists allow us to store multiple objects together.

A list is a sequential group of variables, denoted in Python by square brackets `[]`, with individual entries separated by commas. A few of the neat properties of lists are:

* **Ordered**: The list `[1, 5, 3, 7]` will always store those numbers in the same order.
* **Mixed data types**: `["mercury", 13, 5.3, False]` is a valid list which contains every data type we've seen so far.
* **Can contain other lists**: `[[2, 3], "sulfur", 12, 18]`
* **Can contain repeat values**: `["tomato", "tomato", "tomato", "sulfur"]`

### Indexing

What if we want to extract a specific value from a list? We can use **indexing**. To index in Python, we use the following syntax:

```
variable_name[index]
```

where `index` is the number of the item we wish to extract.

```{r, engine="python"}
alchemists = ["Zosimos", "Oresme", "Flamel", "pseudo-Aristotle"]
print(alchemists[1])
```

Notice that when we printed the item at position 1, we printed out the _second_ entry in `alchemists`. This is because in Python, **indexing begins at 0**. To print out the first entry, we would use `alchemists[0]`.

A couple interesting things we can do with indexing:

* To print multiple consecutive items, we can provie two numbers separated by a colon `:`.

```{r, engine="python"}
print(alchemists[0:2])
```

Note that the first number is **inclusive** and the second number is **exclusive**: we include the item at position 0 (`'Zosimos'`), but not the item at position 2 (`'Flamel'`).

* We can index in reverse. To index from the end of a list, we use negative numbers.

```{r, engine="python", eval=FALSE}
print(alchemists[-1])
```
```{r, engine="python", echo=FALSE}
print(alchemists[-1])
```

***
<details> <summary> Nested lists </summary>

How would we extract the number `3` from the list below?

```{r, engine="python"}
my_list = [1, 2, [3, 4], 5]
```

First, we extract the `[3, 4]` list. This is the third item of the outer list, so it is at position 2 (remember, indexing in Python starts at 0). So we can access the interior list with `my_list[2]`:

```{r, engine="python"}
print(my_list[2])
```

Within the interior list, `3` is the first item, so it is at position 0. It can be accessed with the syntax `my_list[2][0]`:

```{r, engine="python", eval=FALSE}
print(my_list[2][0])
```
```{r, engine="python", echo=FALSE}
print(my_list[2][0])
```

</details>
***

#### Indexing Strings

We can also apply indexing to extract substrings from within a string. This is done identically to how we index a list:

```{r, engine='python'}
creature = 'stingray'
print(creature[0:5])
```

### Adding to lists

Finally, we can add entries to the end of a list. We do this with the `append()` method, which is used with the following syntax:

```
list_name.append(item)
```

For example:

```{r, engine="python"}
florilegium = ['marigold', 'thistle', 'wormwood']
florilegium.append('tansy')
print(florilegium)
```

## For Loops 

In Python, we will often want to perform an action more than once. For example, if we have a list, we might want to operate on every item within the list one by one. 

One way to do this is to make use of a for loop, which is structured like this:

```{r, engine='python', eval=FALSE}
for <temporary_variable> in <thing to loop through>:
    {do something}
```

For example:

```{r, engine='python'}
stations = ["Three Note Oddity", "Radio Londres", "Cherry Ripe", "Swedish Rhapsody"]

for i in stations:
  print(i)
```

Here is how the loop works:

In the line for `i in stations`: we are defining the temporary variable i (the name of this variable is arbitrary). We are also saying that we are looping through `stations`. So in this first iteration of the for loop, i takes on the value of the first item in `stations`, that is "Three Note Oddity". Now we perform all of the indented code, which here is just a single print() statement.

Now we go back and set the value of i to that of the second entry in `stations`, or "Radio Londres". We execute all of the indented code, printing out "Radio Londres".

Now we go back and set the value of i to that of the third value in `stations`, or "Cherry Ripe". And we keep on doing this until there is nothing left in my_list.

In the above example, there was a single indented line in the bodyo of the loop, but the for loop can be arbitrarily long. Here is an example of a for loop structured in the same way, but with more going on in the body of the loop:

```{r, engine='python'}
my_list = [1, 4, 6, 9, 10, 2]

for i in my_list:
  i = i + 3
  i = i ** 2
  print(i)
```

We can also use a for loop to perform an action a set number of times, even when we don’t have a list to loop through. To do so, we can use the range() function. We'll use this function a ton throughout the course. When we run the range() function with a single integer inside the paranthesis, it generates a sequence of numbers from 0 up to and not including the number provided. So to run a function 3 times, we would provide the for loop with range(3) (i.e. [0, 1, 2]).

```{r, engine='python'}
for i in range(3):
  print(i)
```

So far, the body of our for loops has always referenced the temporary variable `i`. We can also use a for loop to run a block of code repeatedly without actually manipulating the temporary variable within that block:

```{r, engine='python'}
for i in range(6):
  print("All work and no play")
```

## Reading in Data and Text Parsing




***FILL***



## Modules 

Often, we need to make use of functions beyond those that are packaged with Python. To do this, we can import a **module**, or a collection of pre-written functions. A module is imported with the following syntax: `import <module name>`. For example, to import the popular plotting module Matplotlib, we write:

```{r, engine='python', eval=FALSE}
import matplotlib.pyplot
```

To use a function from this module, we need to reference both the package name and the function name, with the general syntax: `moduleName.functionName()`. To user Matplotlib's `show()` function, we would write:

```{r, engine='python', eval=FALSE}
matplotlib.pyplot.show()
```

What if you don't want to write out `matplotlib.pyplot` in full each time that you run a Matplotlib function? To simplify this, we can give our modules a shorthand name. For example: 

```{r, engine='python', eval=FALSE}
import matplotlib.pyplot as plt
```

Now, instead of writing out `matplotlib.pyplot`, we can just write `plt`. The previous `matplotlib.pyplot.show()` command is shortened to:

```{r, engine='python', eval=FALSE}
plt.show()
```

## Plotting 

In this course, we will use the library Matplotlib for plotting. For concision, we will import the `matplotlib.pyplot` module with the name `plt`, as such:

```{r, engine='python', eval=FALSE}
import matplotlib.pyplot as plt
```










































































[["index.html", "CMDB Bootcamp 1 Homepage", " CMDB Bootcamp 1 Homepage This is the course homepage and digital textbook for CMDB Bootcamp. 1.0.0.1 Instructors Rajiv McCoy, rajiv.mccoy[at]jhu.edu Mike Sauria, mike.sauria[at]jhu.edu Fred Tan, tan[at]ciwemb.edu 1.0.0.2 Schedule &amp; Logistics Class is Tuesdays from 3-3:50PM, in UTL G89. Please bring your laptop with you to every class. Session Content Session 1: The reference genome &amp; genome browsers Session 2: De novo mutations Session 3: Linkage disequilibrium Session 4: Simulating evolution Session 5: Population structure – part I Session 6: Population structure – part II Session 7: Genome-wide association studies – part I Session 8: Genome-wide association studies – part II Session 9: Scans for selection – part I Session 10: Scans for selection – part II Session 11: Archaic admixture Session 12: Gene expression Session 13: Coronavirus phylogenetics "],["python-cheat-sheet.html", "2 Python Cheat Sheet", " 2 Python Cheat Sheet 2.0.1 Mathematics + and -: addition and subtraction * and /: multiplication and division **: exponentials 2.0.2 Comparisons &lt; and &gt;: greater than, less than &lt;= and &gt;=: greater than or equal to, less than or equal to 2.0.3 String Methods .upper() and .lower(): Convert string to upper or lower case .split(): Split a string on a delimiter into a list .join(): Convert a list into a string using a delimiter .rstrip(), .lstrip(), and .strip(): Remove unwanted characters from the right side, left side, or both sides of a string 2.0.4 Type Conversion float(): Convert data to float int(): Convert data to an integer str(): Convert data to a string 2.0.5 Working with Files open(file, mode): Most common modes are: (r), write (w), append (a) .readlines(): Return a list where each element is a line from the input file .close(): Close the file 2.0.6 List methods .append(): Add an element to the end of a list 2.0.7 Numpy loadtxt(): Import a file array.shape: Return the number of rows and columns of a numpy array object np.mean(): Return the mean of an array. Can use the axis argument for row and column means np.std(): Return the standard deviation of an array. Can use the axis argument for row and column standard deviations np.max(): Return the maximum value of an array. Can be used with axis np.min(): Return the minimum value of an array. Can be used with axis 2.0.8 Plotting plt.subplots(): Initialize a figure with at least one subplot .scatter(): Create a scatter plot .plot(): Create a line plot .his(): Create a histogram .legend(): Add a legend to your figure .set_xlabel() and ax.set_ylabel(): Set x and y labels for a subplot .set_title(): Set a title for a subplot .set_xlim() and .set_ylim(): Set x and y limits for a subplot plt.show(): Display plot "],["the-unix-shell.html", "3 The Unix Shell ", " 3 The Unix Shell "],["introducing-the-shell.html", "3.1 Introducing the Shell", " 3.1 Introducing the Shell "],["navigating-files-and-directories.html", "3.2 Navigating Files and Directories", " 3.2 Navigating Files and Directories "],["working-with-files-and-directories.html", "3.3 Working with Files and Directories", " 3.3 Working with Files and Directories "],["python.html", "4 Python ", " 4 Python "],["data-types.html", "4.1 Data Types", " 4.1 Data Types Integers are whole numbers. For example: 2 -3 0 Floats are numbers with a decimal point. For example: 1.2 -3.0 26/3 (evaluates to 8.666) Strings are characters enclosed by single ' or double \" quotation marks. Any text enclosed by quotes will be treated as a string. \"My Grandpa's deck has no pathetic cards\" '85.3' Note the second example – 85.3 is a float; '85.3' is a string. Booleans have two possible values: True and False. These can also be expressed as 1 (true) or 0 (false). "],["variables.html", "4.2 Variables", " 4.2 Variables Variables are assigned using the = sign: variable_name = value For example: composer = \"buxtehude\" year = 1637 The variable name can be almost anything. Here are some general rules to consider when naming a variable: The name must start with a letter or underscore The name can only consist of letters, numbers, or underscores Variables are case sensitive (i.e. Python interprets my_number, MY_NUMBER, and My_Number as different variables) Python has a set of “reserved words” that cannot be used as variable names. These are words that already have a set meaning in Python, such as True, False, for, and if. A full list can be found here. "],["python-1.html", "5 Python ", " 5 Python "],["math.html", "5.1 Math", " 5.1 Math 5.1.1 Mathematical operations A lot of mathematical operations in Python are straightforward. Here are some of the basic operations we can perform: + and -: addition and subtraction * and /: multiplication and division **: exponentials We can perform mathematical operations on values directly: print(2 + 3) ## 5 Or we can operate on variables: myValue = 4 print(myValue**2) ## 16 Python will automatically convert integers to floats when appropriate: print(3 + 2.2) ## 5.2 We can save the output of an expression as a variable: my_product = 2 * 10 print(my_product) ## 20 And likewise we can perform mathematical operations on variables, if these variables store numeric data: number1 = 7 print(number1 / 2) ## 3.5 5.1.2 Order of operations Python follows the usual mathematical order of operations. And like in math, we can use parentheses () to enforce a specific order. print(2 * (2 + 2)) ## 8 "],["python-2.html", "6 Python ", " 6 Python "],["comparisons-1.html", "6.1 Comparisons", " 6.1 Comparisons In Python, comparisons will always return a Boolean, i.e. either True or False. We can use the following syntax to compare values: &lt; and &gt;: greater than, less than &lt;= and &gt;=: greater than or equal to, less than or equal to For example: print(5.3 &lt; 17) ## True print(4. &gt;= (8/2)) ## True == checks if two values are equal. != checks if two values are different. print(2 == (10 - 8)) ## True Note that a single equals sign = is used to assign values. However, a double equals sign == is used to compare values. var1 = 3 sets the variable var1 to 3 var1 == 3 checks whether the value of var1 is 3 "],["python-3.html", "7 Python ", " 7 Python "],["built-in-functions-and-methods.html", "7.1 Built-In Functions and Methods", " 7.1 Built-In Functions and Methods 7.1.1 Functions A function is a block of code that performs a task. Python comes with a substantial set of pre-written functions. Text on how a function is formulated - name, parentheses, optionally arguments Is it worth talking about named arguments or positional arguments. Be introspective about this For example, the print() function displays FINISH ME OTHER Built-In FUNCTIONS’ 7.1.2 Methods Every data type that we use in Python (strings, integers, etc.) is associated with a set of functions unique to the data type. These functions are called methods. The syntax for using a method is: &lt;objectName&gt;.&lt;methodName&gt;() 7.1.2.1 Example The string method .upper() is used to convert a string into uppercase letters. We can use it either directly on the string itself: &quot;peppa&quot;.upper() ## &#39;PEPPA&#39; or by operating on a variable: pig = &quot;peppa&quot; pig.upper() ## &#39;PEPPA&#39; 7.1.2.2 Modifying objects Using a method may or not modify the object you run it on. For example, the .upper() method shows you the uppercase version of a string but does not modify the actual object that you are operating on. Observe the following code block: pig = &quot;peppa&quot; pig.upper() print(pig) ## peppa pig has not been updated. To actually save the result of .upper(), we have to assign it to a variable: pig_caps = pig.upper() print(pig_caps) ## PEPPA Some methods do modify underlying variables. For example, the list .append() method (which we will learn about later) does change the list if operates on: myList = [] print(myList) ## [] myList.append(&#39;apple&#39;) print(myList) ## [&#39;apple&#39;] myList is altered by myList.append('apple'). There’s no need to type something like myList = myList.append('apple') - this would in fact be an error. Whether methods modify the objects they operate on is something you’ll have to keep track of on a case-by-case basis as you learn new methods. "],["python-4.html", "8 Python ", " 8 Python "],["type-conversion-1.html", "8.1 Type Conversion", " 8.1 Type Conversion Sometimes, data can be converted from one type to another. float() - converts integers and strings (when appropriate) to floats print(float(3)) print(float(&quot;2.57&quot;)) 3.0 2.57 int()converts floats and strings into integers. Note that this function always rounds down if necessary. An exception here: int() does not allow you to convert a string with a decimal point into an integer - int(\"3.62\") will throw an error. print(int(&#39;3&#39;)) print(int(2.57)) 3 2 Note that for the above functions, it is not always possible to do convert data into a different type. In particular, strings with non-numeric characters cause problems - int(\"Dachshund\") will not work. str() converts all other data types into strings. print(str(3)) print(str(2.57)) print(str(True)) &#39;3&#39; &#39;2.57&#39; &#39;True&#39; A special case of type conversions comes with booleans. Numeric values are automatically converted into booleans. 0 is equivalent to False. All non-zero numeric values are equivalent to True. Likewise, empty strings ('') convert to False. All non-empty strings (inlcuding the string 'False') convert to True. "],["python-5.html", "9 Python ", " 9 Python "],["string-methods-1.html", "9.1 String Methods", " 9.1 String Methods 9.1.1 .upper() and .lower() The .upper() and .lower() methods take a string and convert it to uppercase and lowercase, respectively. print(&quot;out on the wily, windy moors&quot;.upper()) ## OUT ON THE WILY, WINDY MOORS aria = &quot;Piangerò La Sorte Mia&quot; print(aria.lower()) ## piangerò la sorte mia 9.1.2 .split() The .split() method takes a string and splits it into a list, dividing the list on a delimiter (i.e., separator). The delimiter is provided as an argument: print(&quot;Newt eye, frog toe&quot;.split(&#39;,&#39;)) ## [&#39;Newt eye&#39;, &#39; frog toe&#39;] If no argument is provided, then the string is split on whitespace (that is, it is split whenever a space or tab is encountered). print(&quot;Eye of newt and toe of frog&quot;.split()) ## [&#39;Eye&#39;, &#39;of&#39;, &#39;newt&#39;, &#39;and&#39;, &#39;toe&#39;, &#39;of&#39;, &#39;frog&#39;] 9.1.3 .join() The .join() method is the inverse of .split(): converts a list into a string, with list elements separated by a delimiter. The general syntax is: &quot;&lt;delimiter&gt;&quot;.join(&lt;list&gt;) For example: &quot; &quot;.join([&quot;I&quot;, &quot;found&quot;, &quot;a&quot;, &quot;fox&quot;, &quot;caught&quot;, &quot;by&quot;, &quot;dogs&quot;]) ## &#39;I found a fox caught by dogs&#39; If we do not provide a delimiter, then the strings are directly concatenated: &quot;&quot;.join([&quot;I&quot;, &quot;found&quot;, &quot;a&quot;, &quot;fox&quot;, &quot;caught&quot;, &quot;by&quot;, &quot;dogs&quot;]) ## &#39;Ifoundafoxcaughtbydogs&#39; 9.1.4 .rstrip(), .lstrip(), .strip() These three methods remove unwanted characters on the right, left, or both sides of a string. You can provide the characters you want to remove as an argument: &quot;ricercar........,,,,,,&quot;.rstrip(&quot;,.&quot;) ## &#39;ricercar&#39; Without an argument, the methods remove spaces: &quot; ricercar &quot;.lstrip() ## &#39;ricercar &#39; Note that in the above example we strip the spaces to the left of the main text, but we do not remove the spaces from the middle or right end of the text. "],["python-6.html", "10 Python ", " 10 Python "],["lists.html", "10.1 Lists", " 10.1 Lists Lists allow us to store multiple objects together. A list is a sequential group of variables, denoted in Python by square brackets [], with individual entries separated by commas. A few of the neat properties of lists are: Ordered: The list [1, 5, 3, 7] will always store those numbers in the same order. Mixed data types: [\"mercury\", 13, 5.3, False] is a valid list which contains every data type we’ve seen so far. Can contain other lists: [[2, 3], \"sulfur\", 12, 18] Can contain repeat values: [\"tomato\", \"tomato\", \"tomato\", \"sulfur\"] 10.1.1 Indexing What if we want to extract a specific value from a list? We can use indexing. To index in Python, we use the following syntax: variable_name[index] where index is the number of the item we wish to extract. alchemists = [&quot;Zosimos&quot;, &quot;Oresme&quot;, &quot;Flamel&quot;, &quot;pseudo-Aristotle&quot;] print(alchemists[1]) ## Oresme Notice that when we printed the item at position 1, we printed out the second entry in alchemists. This is because in Python, indexing begins at 0. To print out the first entry, we would use alchemists[0]. A couple interesting things we can do with indexing: To print multiple consecutive items, we can provide two numbers separated by a colon :. print(alchemists[0:2]) ## [&#39;Zosimos&#39;, &#39;Oresme&#39;] Note that the first number is inclusive and the second number is exclusive: we include the item at position 0 ('Zosimos'), but not the item at position 2 ('Flamel'). We can index in reverse. To index from the end of a list, we use negative numbers. print(alchemists[-1]) ## pseudo-Aristotle Nested lists How would we extract the number 3 from the list below? my_list = [1, 2, [3, 4], 5] First, we extract the [3, 4] list. This is the third item of the outer list, so it is at position 2 (remember, indexing in Python starts at 0). So we can access the interior list with my_list[2]: print(my_list[2]) ## [3, 4] Within the interior list, 3 is the first item, so it is at position 0. It can be accessed with the syntax my_list[2][0]: print(my_list[2][0]) ## 3 10.1.1.1 Indexing Strings We can also apply indexing to extract substrings from within a string. This is done identically to how we index a list: creature = &#39;stingray&#39; print(creature[0:5]) ## sting 10.1.2 Adding to lists Finally, we can add entries to the end of a list. We do this with the append() method, which is used with the following syntax: list_name.append(item) For example: florilegium = [&#39;marigold&#39;, &#39;thistle&#39;, &#39;wormwood&#39;] florilegium.append(&#39;tansy&#39;) print(florilegium) ## [&#39;marigold&#39;, &#39;thistle&#39;, &#39;wormwood&#39;, &#39;tansy&#39;] "],["python-7.html", "11 Python ", " 11 Python "],["for-loops.html", "11.1 For Loops", " 11.1 For Loops In Python, we will often want to perform an action more than once. For example, if we have a list, we might want to do the same operatation on every item within the list. One way to do this is to use a for loop, which is structured like this: for &lt;temporary_variable&gt; in &lt;thing to loop through&gt;: {do something} For example: stations = [&quot;Oddity&quot;, &quot;Londres&quot;, &quot;Cherry&quot;, &quot;Swedish&quot;] for i in stations: print(i) ## Oddity ## Londres ## Cherry ## Swedish 11.1.1 For loop walkthrough Here is how the loop works: for i in stations: In this line, we: Define the temporary variable i. The name of this variable is arbitrary. We say that we are looping through stations. In the first iteration of the for loop, i takes on the value of the first item in stations (\"Oddity\"). Now we perform all of the indented code, which here is just a print() statement. In the second iteration of the for loop, we set the value of i to the second entry in stations (\"Londres\"). We execute all of the indented code, printing out \"Londres\". We continue on doing this until there is nothing left in stations. In this example, there was a single line in the body of the loop, but a for loop can be arbitrarily long. Here is a longer example: my_list = [1, 4, 6, 9, 10, 2] for i in my_list: i = i + 3 i = i ** 2 print(i) ## 16 ## 49 ## 81 ## 144 ## 169 ## 25 11.1.2 Repeating an action n times We can also use a for loop to perform an action a set number of times, even when we don’t have a list to loop through. To do so, we can use the range() function. We’ll use this function a ton throughout the course. range(&lt;n&gt;), where n is a single integer, generates a sequence of numbers from 0 to n (not including n itself). So to run a function 3 times, we would provide the for loop with range(3) (which generates the list [0, 1, 2]). for i in range(3): print(i) ## 0 ## 1 ## 2 So far, the body of our for loop has always referenced the temporary variable i. We can also use a for loop to run a block of code repeatedly without actually manipulating i: for i in range(3): print(&quot;All work and no play&quot;) ## All work and no play ## All work and no play ## All work and no play "],["python-8.html", "12 Python ", " 12 Python "],["reading-in-data.html", "12.1 Reading in Data", " 12.1 Reading in Data When working in Python, we often want to import data from an external file or, conversely, write our data to a file. To interact with external data objects, we use the open() function. This function takes two arguments: the name of the file we want to work with, and the mode that we want to interact with this file. The common modes we use are: r - Read. This allows us to import data from an external file into python. w - Write. This allows us to write our data to a file. If a file with this name already exists, operating in w mode will overwrite existing file contents. a - Append. This allows us to write our data to a file. If a file with this name already exists, operating in a mode will add to existing file contents. To open a file with the name insects.txt, for reading in file contents, we would therefore use the syntax: f = open(&#39;insects.txt&#39;, &#39;r&#39;) 12.1.1 Parsing a file If we try to print() f, we get the following output: &lt;_io.TextIOWrapper name='insects.txt' mode='r' encoding='UTF-8'&gt; This is because we have opened the file and saved it as a variable, but we haven’t actually read through and manipulated the data which it contains. We have two main ways of doing this in base Python: 12.1.1.1 1. Parsing with a for loop One way to look through a file’s contents line by line is to use a for loop. We can loop through a file with the syntax: for line in f: print(line) ## Hercules beetle ## ## Swallowtail ## ## Ornate mantis ## ## Weevil ## ## Pine chaffer As it turns out, at the end of each line, there is a special end of line character, \\n. To just read in the data without the return character, we can use .strip(): for line in f: print(line.strip(&#39;\\n&#39;)) 12.1.1.2 2. Parsing with readlines() readlines() is a method that allows us to read through the entire file all at once, returning file contents as a list: ## [&#39;Hercules beetle\\n&#39;, &#39;Swallowtail\\n&#39;, &#39;Ornate mantis\\n&#39;, &#39;Weevil\\n&#39;, &#39;Pine chaffer\\n&#39;] This is more concise than a for loop, but all lines are read in without the manipulations that we can perform line-by-line in our loop. 12.1.1.3 Closing files We can close a file with the .close() method. To close insects.txt (previously saved as the variable f), we would run: Once the file is closed, we cannot read it or write to it without opening it again. "],["python-9.html", "13 Python ", " 13 Python "],["modules.html", "13.1 Modules", " 13.1 Modules Often, we need to make use of functions beyond the basic ones in Python. To do this, we can import a module, or a collection of pre-written functions. A module is imported with the following syntax: import &lt;module name&gt; For example, to import the popular plotting module Matplotlib, we write: import matplotlib.pyplot 13.1.1 Module functions To use a function from Matplotlib, we need to reference both the package name and the function name, with the general syntax: moduleName.functionName() To use Matplotlib’s show() function, we would write: matplotlib.pyplot.show() 13.1.2 Abbreviating module names What if you don’t want to write out matplotlib.pyplot every time you run a Matplotlib function? To simplify this, we can give our modules a shorthand name. For example: import matplotlib.pyplot as plt Now, instead of writing out matplotlib.pyplot, we can just write plt. The previous matplotlib.pyplot.show() command is shortened to: plt.show() "],["python-10.html", "14 Python ", " 14 Python "],["numpy-1.html", "14.1 Numpy", " 14.1 Numpy Numpy is a Python library used for manipulating arrays and performing mathematical operations on matrices. For concision, we will import the numpy module with the name np, as such: import numpy as np 14.1.1 Reading in data The function np.loadtxt() is used to read in text data. The most basic way to run np.loadtxt() is: np.loadtxt(&lt;fname&gt;) Consider a hypothetical comma-delimited file numbers.csv. The most basic way of reading it in is to run np.loadtxt('numbers.csv'). However, when we read in data, we typically want to store it in memory for further manipulation, so we usually use np.loadtxt() in conjunction with variable assignment: myNumbers = np.loadtxt(&#39;numbers.csv&#39;) However, with a comma-delimited file as input this is likely to cause an error - Python has no way of knowing that elements in your file are separated by a space and will throw an error because something like “1,2,3” cannot be interpreted as a single numeric value. To tell Python that our data is comma-delimited, we can use the optional argument, delimiter: myNumbers = np.loadtxt(&#39;numbers.csv&#39;, delimiter=&#39;,&#39;) Now, each number is encoded as its own element: array([1, 2, 3]) Notice that unlike the file name, we need to specify the name of this optional argument (delimiter=). Because the file name argument is mandatory, numpy always expects the first argument to be the filename. However, since there are many possible optional arguments that once can use, it is impossible to infer which optional argument is being referred to by position alone. For optional arguments, we always need to specify their name. np.loadtxt() has many useful optional arguments - for example skiplines, which allows the user to skip the first n lines of a file. A full list of the optional arguments to np.loadtxt() can be found here 14.1.2 Indexing numpy arrays Within a numpy array, we often want to look at a specific element or set of elements. To do this, we use indexing. First, we can see the total size of an array by looking at the array’s shape attribute. An attribute is a property inherent to a specific data type; it is typically viewed with the following syntax: print(&lt;variableName&gt;.&lt;attributeName&gt;). We can therefore look at the shape of our array as such: print(myNumbers.shape). This returns the number of rows and columns, respectively: (45, 12) - 45 rows and 12 columns. 14.1.2.1 Accessing Single Values To look within these rows and columns for specific values, we use indexing: dataName[&lt;rowNumber&gt;, &lt;columnNumber&gt;] For example, to print the value in the fifth row and third column of myNumbers, we would write: print(myNumbers[4, 2]) Remember that in Python, we start counting at 0. 14.1.2.2 Accessing Multiple Values To print multiple consecutive items, we can provide two numbers separated by a colon :. print(myNumbers[2:4, 5:10]) Note that the first number is inclusive and the second number is exclusive: We will print the elements in rows 3 and 4 and not row 5. We will print the the elements in columns 6 through 10, and not in column 11. 14.1.3 Math in numpy Consider the numpy array, which is saved with the name sequence: [[1,2,3], [4,5,6]] 14.1.4 Average, Standard Deviation, Maximum, Minimum To take the average of this array, we use the function np.mean(). np.mean() has one required argument, which is the name of the object you want to take the mean of. Running this function on sequence will return 3.5, which is indeed the average of all six elements: np.mean(sequence) 3.5 Conveniently, we can also use this same function to calculate the averages across rows and columns, by invoking the optional axis argument. Setting axis equal to 0 will produce column means; setting axis to 1 will produce row means: np.mean(sequence, axis=0) array([2.5, 3.5, 4.5]) np.mean(sequence, axis=1) array([2., 5.]) To compute the standard deviation, we use the np.std(). As with np.mean(), we can provide the axis argument to calculate the standard deviation along rows or columns. We can get the maximum and minimum values of a numpy array using the np.max() and np.min() functions, respectively. These can also take the axis argument to operate along rows and columns. "],["python-11.html", "15 Python ", " 15 Python "],["plotting-with-matplotlib.html", "15.1 Plotting with matplotlib", " 15.1 Plotting with matplotlib In this course, we will use the library Matplotlib for plotting. For concision, we will import the matplotlib.pyplot module with the name plt, as such: import matplotlib.pyplot as plt 15.1.1 Line and Scatter Plots - Walkthrough We can initialize a figure with the following line: fig, ax = plt.subplots() This initializes a figure (named fig) and a plot within the figure (named ax). Having separate variables for the figure and the plot within the figure may seem strange, but it will make it considerably easier to arrange and manipulate multiple subplots within a larger figure. At present, our figure is just am empty canvas: 15.1.1.1 Points and Lines Let’s add to our subplot by plotting some data. I’ve stored the temperature in Fahrenheit in Baltimore, MD and Wommels, Netherlands for the next seven hours: hours = range(7) tempBaltimore = [74, 73, 72, 71, 75, 79, 87] tempWommels = [59, 60, 62, 65, 69, 72, 67] To plot a set of points, we can use the .scatter() method This function takes two mandatory arguments: a list of x coordinates and a list of y coordinates. We can plot the temperature in Baltimore as such: ax.scatter(hours, tempBaltimore) We can display our plot by running the function plt.show(). Our plot will look like this: Note that the .scatter() method has a variety of optional arguments that can be used to configure the appearance of your pointts - we will often modify the color (c), size (s), and shape (m) of our points. A full list of options can be found here. To add a line, we use the .plot() method. Like .scatter(), this function takes as arguments lists of x and y positions, and allows for aesthetic customization with a variety of optional parameters. (for more information on those, look here) our plotting code now looks like this: import matplotlib.pyplot as plt hours = range(7) tempBaltimore = [74, 73, 72, 71, 75, 79, 87] tempWommels = [59, 60, 62, 65, 69, 72, 67] fig, ax = plt.subplots() ax.scatter(hours, tempBaltimore) ax.plot(hours, tempBaltimore) plt.show() and generates this image: 15.1.1.2 Multiple Sets of Data To plot both Baltimore and Wommels, we simply add a second call to .scatter() and .plot() fig, ax = plt.subplots() ax.scatter(hours, tempBaltimore) ax.plot(hours, tempBaltimore) ax.scatter(hours, tempWommels) ax.plot(hours, tempWommels) plt.show() A couple things are interesting about this plot: The y axis scale adjust automatically to fit in Wommels. The second time that we call the .scatter() and .plot() functions, they automatically plot in a new color. If we were to add a third set of points, they would again be in a new color. 15.1.1.3 Labels and Legends To an observe, our plot is a bit confusing because it is unclear which line represents Wommels and which line represents Baltimore. We could clarify this by adding a legend. There are two steps to doing this: We need to use the optional label argument. This argument lets the interpreter how to label a line or set of points in the legend. For example, we can label a set of points as such: ax.scatter(hours, tempBaltimore, label='Baltimore'). In this example, we can label either the scatter plots or the line plots. Create a legend using the .legend() method fig, ax = plt.subplots() ax.scatter(hours, tempBaltimore, label=&#39;Baltimore&#39;) ax.plot(hours, tempBaltimore) ax.scatter(hours, tempWommels, label=&#39;Wommels&#39;) ax.plot(hours, tempWommels) ax.legend() plt.show() 15.1.1.4 Figure Aesthetics Now that our data is plotted, let’s add some axis labels using the .set_xlabel() and .set_ylabel() methods: ax.set_xlabel(&quot;Time (Hours)&quot;) ax.set_ylabel(&quot;Temperature (F)&quot;) We can set a title as such: ax.set_title(&#39;Temperature in Baltimore and Wommels&#39;) If we wanted to set custom limits for our x and ylimits, we can use the set_xlim() and set_ylim() methods: ax.set_ylim(50, 100) Altogether, our final image looks like this: 15.1.2 Histograms Histograms are a convenient way of visually displaying the overall distribution of a one-dimensional dataset. I’ve found 25 towns worldwide named Baltimore. Here are their current temperature in Fahrenheit saved to a list: temperatureBaltimore = [69, 83, 82, 90, 77, 89, 82, 67, 59, 86, 74, 77, 58, 67, 62, 91, 73, 81, 67, 87, 61, 67, 61, 108, 112] To generate a histogram, we use the .hist() method. By default, this method takes just one argument - the data that you wish to plot. fig, ax = plt.subplots() ax.hist(temperatureBaltimore) ax.set_xlabel(&#39;Temperature (F)&#39;) ax.set_ylabel(&#39;Frequency&#39;) ax.set_title(&#39;Current Temperature in Every Town Named Baltimore&#39;) plt.show() One important argument for the .hist() method is bins, which allows us to set how many groups our data is divided into. The more bins there are, the fewer x values will be contained within a single bin. For example, plotting the Baltimore data with a larger number of bins: ax.hist(temperatureBaltimore, bins = 20) "],["errors.html", "15.2 Errors", " 15.2 Errors "],["git.html", "16 Git ", " 16 Git "],["tracking-changes.html", "16.1 Tracking Changes", " 16.1 Tracking Changes "],["ignoring-things.html", "16.2 Ignoring Things", " 16.2 Ignoring Things "],["authors.html", "Authors", " Authors     Credits Names Pedagogy Instructor Rajiv McCoy Content Author Stephanie Yan Content Author Kate Weaver Website Template Jeff Leek &amp; The Johns Hopkins Data Science Lab Design Inspiration Ali Madooei &amp; JHU Data Structures Funding JHU Center for Educational Resources Techology Fellowship Grant   ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 4.0.2 (2020-06-22) ## os Ubuntu 20.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz Etc/UTC ## date 2023-08-18 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## assertthat 0.2.1 2019-03-21 [1] RSPM (R 4.0.5) ## bookdown 0.24 2023-03-28 [1] Github (rstudio/bookdown@88bc4ea) ## bslib 0.4.2 2022-12-16 [1] CRAN (R 4.0.2) ## cachem 1.0.7 2023-02-24 [1] CRAN (R 4.0.2) ## callr 3.5.0 2020-10-08 [1] RSPM (R 4.0.2) ## cli 3.6.1 2023-03-23 [1] CRAN (R 4.0.2) ## crayon 1.3.4 2017-09-16 [1] RSPM (R 4.0.0) ## desc 1.2.0 2018-05-01 [1] RSPM (R 4.0.3) ## devtools 2.3.2 2020-09-18 [1] RSPM (R 4.0.3) ## digest 0.6.25 2020-02-23 [1] RSPM (R 4.0.0) ## ellipsis 0.3.1 2020-05-15 [1] RSPM (R 4.0.3) ## evaluate 0.20 2023-01-17 [1] CRAN (R 4.0.2) ## fansi 0.4.1 2020-01-08 [1] RSPM (R 4.0.0) ## fastmap 1.1.1 2023-02-24 [1] CRAN (R 4.0.2) ## fs 1.5.0 2020-07-31 [1] RSPM (R 4.0.3) ## glue 1.4.2 2020-08-27 [1] RSPM (R 4.0.5) ## here 1.0.1 2020-12-13 [1] CRAN (R 4.0.2) ## hms 0.5.3 2020-01-08 [1] RSPM (R 4.0.0) ## htmltools 0.5.5 2023-03-23 [1] CRAN (R 4.0.2) ## jquerylib 0.1.4 2021-04-26 [1] CRAN (R 4.0.2) ## jsonlite 1.7.1 2020-09-07 [1] RSPM (R 4.0.2) ## knitr 1.33 2023-03-28 [1] Github (yihui/knitr@a1052d1) ## lattice 0.20-41 2020-04-02 [2] CRAN (R 4.0.2) ## lifecycle 1.0.3 2022-10-07 [1] CRAN (R 4.0.2) ## magrittr 2.0.3 2022-03-30 [1] CRAN (R 4.0.2) ## Matrix 1.2-18 2019-11-27 [2] CRAN (R 4.0.2) ## memoise 2.0.1 2021-11-26 [1] CRAN (R 4.0.2) ## ottrpal 1.0.1 2023-03-28 [1] Github (jhudsl/ottrpal@151e412) ## pillar 1.9.0 2023-03-22 [1] CRAN (R 4.0.2) ## pkgbuild 1.1.0 2020-07-13 [1] RSPM (R 4.0.2) ## pkgconfig 2.0.3 2019-09-22 [1] RSPM (R 4.0.3) ## pkgload 1.1.0 2020-05-29 [1] RSPM (R 4.0.3) ## png 0.1-8 2022-11-29 [1] CRAN (R 4.0.2) ## prettyunits 1.1.1 2020-01-24 [1] RSPM (R 4.0.3) ## processx 3.4.4 2020-09-03 [1] RSPM (R 4.0.2) ## ps 1.4.0 2020-10-07 [1] RSPM (R 4.0.2) ## R6 2.4.1 2019-11-12 [1] RSPM (R 4.0.0) ## rappdirs 0.3.3 2021-01-31 [1] CRAN (R 4.0.2) ## Rcpp 1.0.10 2023-01-22 [1] CRAN (R 4.0.2) ## readr 1.4.0 2020-10-05 [1] RSPM (R 4.0.2) ## remotes 2.2.0 2020-07-21 [1] RSPM (R 4.0.3) ## reticulate 1.28 2023-01-27 [1] CRAN (R 4.0.2) ## rlang 1.1.0 2023-03-14 [1] CRAN (R 4.0.2) ## rmarkdown 2.10 2023-03-28 [1] Github (rstudio/rmarkdown@02d3c25) ## rprojroot 2.0.3 2022-04-02 [1] CRAN (R 4.0.2) ## rstudioapi 0.11 2020-02-07 [1] RSPM (R 4.0.0) ## sass 0.4.5 2023-01-24 [1] CRAN (R 4.0.2) ## sessioninfo 1.1.1 2018-11-05 [1] RSPM (R 4.0.3) ## stringi 1.5.3 2020-09-09 [1] RSPM (R 4.0.3) ## stringr 1.4.0 2019-02-10 [1] RSPM (R 4.0.3) ## testthat 3.0.1 2023-03-28 [1] Github (R-lib/testthat@e99155a) ## tibble 3.2.1 2023-03-20 [1] CRAN (R 4.0.2) ## usethis 1.6.3 2020-09-17 [1] RSPM (R 4.0.2) ## utf8 1.1.4 2018-05-24 [1] RSPM (R 4.0.3) ## vctrs 0.6.1 2023-03-22 [1] CRAN (R 4.0.2) ## withr 2.3.0 2020-09-22 [1] RSPM (R 4.0.2) ## xfun 0.26 2023-03-28 [1] Github (yihui/xfun@74c2a66) ## yaml 2.2.1 2020-02-01 [1] RSPM (R 4.0.3) ## ## [1] /usr/local/lib/R/site-library ## [2] /usr/local/lib/R/library "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
